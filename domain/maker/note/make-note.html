<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Music Notes Wave Animator</title>
<style>
body { display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; background:#111; color:#fff; font-family:Arial, sans-serif; margin:0; padding:20px; }
#controls { display:flex; flex-wrap:wrap; gap:15px; margin-bottom:20px; }
#controls label { display:flex; flex-direction:column; font-size:14px; }
canvas { background:transparent; display:block; border:1px solid #444; }
button { padding:8px 15px; font-size:14px; cursor:pointer; }
</style>
</head>
<body>

<div id="controls">
    <label>음표 색상: <input type="color" id="noteColor" value="#ff00ff"></label>
    <label>최소 음표 수: <input type="number" id="minNotes" value="3" min="1" max="10"></label>
    <label>최대 음표 수: <input type="number" id="maxNotes" value="7" min="1" max="10"></label>
    <label>캔버스 가로: <input type="number" id="canvasWidth" value="800" min="100"></label>
    <label>캔버스 세로: <input type="number" id="canvasHeight" value="200" min="50"></label>
    <label>속도: <input type="number" id="speed" value="0.05" step="0.01" min="0.01" max="0.2"></label>
    <label>물결 높이: <input type="number" id="waveHeight" value="20" min="5" max="100"></label>
    <label>랜덤 음표: <input type="checkbox" id="randomNotes" checked></label>
    <label>음표 선택 (쉼표로 구분): <input type="text" id="customNotes" value="♫,♪,♬,♩,♭"></label>
    <button id="saveGifBtn">GIF 저장</button>
</div>

<canvas id="musicCanvas"></canvas>

<script src="/js/lib/gif.js"></script>
<script>
const canvas = document.getElementById('musicCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

let config = {
    color:'#ff00ff',
    canvasWidth:800,
    canvasHeight:200,
    minNotes:3,
    maxNotes:7,
    speed:0.05,
    waveHeight:20,
    randomNotes:true,
    customNotes:['♫','♪','♬','♩','♭']
};

let notesString = '';
let fontSize = config.canvasHeight*0.6;
let time = 0;

// GUI에서 설정값 읽기
function updateConfigFromGUI() {
    config.color = document.getElementById('noteColor').value;
    config.minNotes = parseInt(document.getElementById('minNotes').value);
    config.maxNotes = parseInt(document.getElementById('maxNotes').value);
    config.canvasWidth = parseInt(document.getElementById('canvasWidth').value);
    config.canvasHeight = parseInt(document.getElementById('canvasHeight').value);
    config.speed = parseFloat(document.getElementById('speed').value);
    config.waveHeight = parseFloat(document.getElementById('waveHeight').value);
    config.randomNotes = document.getElementById('randomNotes').checked;
    config.customNotes = document.getElementById('customNotes').value.split(',').map(s=>s.trim()).filter(s=>s);

    canvas.width = config.canvasWidth;
    canvas.height = config.canvasHeight;
    fontSize = Math.min(config.canvasHeight*0.6, config.canvasHeight/2 - config.waveHeight); // 음표 크기와 물결 높이 고려
}

// 음표 문자열 생성
function generateNotes() {
    const count = Math.floor(Math.random()*(config.maxNotes - config.minNotes +1)) + config.minNotes;
    let notes = [];
    for(let i=0;i<count;i++){
        if(config.randomNotes){
            const randIndex = Math.floor(Math.random()*config.customNotes.length);
            notes.push(config.customNotes[randIndex]);
        } else {
            notes.push(config.customNotes[i%config.customNotes.length]);
        }
    }
    return notes.join('');
}

// 애니메이션 (제자리 물결)
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.font = `${fontSize}px Arial`;
    ctx.fillStyle = config.color;

    const startX = (canvas.width - notesString.length*fontSize*0.8)/2;
    const centerY = canvas.height/2;

    for(let i=0;i<notesString.length;i++){
        let char = notesString[i];
        let charX = startX + i*fontSize*0.8;
        let offsetY = Math.sin(time + i) * config.waveHeight;
        let charY = Math.min(canvas.height - fontSize/2, Math.max(fontSize/2, centerY + offsetY));
        ctx.fillText(char,charX,charY);
    }

    time += config.speed;
    requestAnimationFrame(draw);
}

// 초기 설정
updateConfigFromGUI();
notesString = generateNotes();
draw();

// GUI 이벤트
document.getElementById('noteColor').addEventListener('input', ()=>{ config.color=document.getElementById('noteColor').value });
['minNotes','maxNotes','canvasWidth','canvasHeight','speed','waveHeight','randomNotes','customNotes'].forEach(id=>{
    document.getElementById(id).addEventListener('change', ()=>{
        updateConfigFromGUI();
        notesString = generateNotes();
    });
});

// GIF 저장 (비동기, 안정화)
// GIF 저장 (비동기, 안정화)
document.getElementById('saveGifBtn').addEventListener('click', () => {
    const gif = new GIF({
        workers: 2,
        quality: 10,
        width: config.canvasWidth,
        height: config.canvasHeight,
        workerScript: '/js/lib/gif.worker.js' // 워커 스크립트 명시
    });

    const frameCount = 50;
    const delay = 50;
    let tempTime = time;
    let i = 0;

    alert("GIF 생성 중입니다. 잠시만 기다려주세요...");

    function addNextFrame() {
        if (i >= frameCount) {
            gif.render();
            return;
        }

        // 캔버스 상태 초기화 및 명시적 설정
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${fontSize}px Arial`;
        ctx.fillStyle = config.color;
        const startX = (canvas.width - notesString.length * fontSize * 0.8) / 2;
        const centerY = canvas.height / 2;

        for (let j = 0; j < notesString.length; j++) {
            let charX = startX + j * fontSize * 0.8;
            let offsetY = Math.sin(tempTime + j) * config.waveHeight;
            let charY = Math.min(canvas.height - fontSize / 2, Math.max(fontSize / 2, centerY + offsetY));
            ctx.fillText(notesString[j], charX, charY);
        }

        gif.addFrame(canvas, { delay: delay, copy: true });
        tempTime += config.speed;
        i++;
        requestAnimationFrame(addNextFrame); // setTimeout 대신 requestAnimationFrame 사용
    }

    addNextFrame();

    gif.on('finished', function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'music_notes.gif';
        a.click();
        URL.revokeObjectURL(url); // 메모리 누수 방지
    });

    gif.on('error', function(error) {
        console.error('GIF 생성 오류:', error);
        alert('GIF 생성 중 오류가 발생했습니다. 콘솔을 확인해주세요.');
    });
});
</script>

</body>
</html>